name: Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  ELASTICSEARCH_URL: ${{ secrets.ELASTICSEARCH_ENDPOINT }}
  ELASTICSEARCH_INDEX: "flint-workflow-logs"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Compile
        id: compile
        run: |
          # Compile only without running tests and capture output
          mkdir -p logs
          CARGO_TERM_COLOR=never cargo build --tests > logs/compile_output.log 2>&1
          
          # Save the exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Run tests with JSON output
        id: run_tests
        if: steps.compile.outputs.exit_code == '0'
        run: |
          # Run tests with JSON output only
          # The --format=json flag must be passed after -- to be sent to the test binary
          CARGO_TERM_COLOR=never RUSTFLAGS=-Awarnings cargo test > logs/test_output.json 2>&1
          
          # Save the exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Send logs to Elasticsearch
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            // Read the compilation output
            let compileOutput = "";
            try {
              compileOutput = fs.readFileSync('logs/compile_output.log', 'utf8');
              console.log("Successfully read compilation logs");
            } catch (error) {
              console.log("Error reading compilation logs:", error);
              compileOutput = "Failed to read compilation output: " + error.message;
            }
            
            // Read the JSON test output file
            let testOutput = "";
            let testJsonOutput = [];
            try {
              testOutput = fs.readFileSync('logs/test_output.json', 'utf8');
              console.log("Successfully read test JSON logs");
            
              // Print the first 500 characters to debug
              console.log("Test output preview:", testOutput.substring(0, 500));
            
              // Try to parse the JSON output
              try {
                // The output might contain multiple JSON objects, one per line
                testJsonOutput = testOutput.trim().split('\n')
                  .filter(line => line.trim().startsWith('{'))
                  .map(line => {
                    try { return JSON.parse(line); } 
                    catch (e) { 
                      console.log("Failed to parse JSON line:", line.substring(0, 100));
                      return null; 
                    }
                  })
                  .filter(obj => obj !== null);
            
                console.log(`Found ${testJsonOutput.length} valid JSON objects in test output`);
              } catch (parseError) {
                console.log("Error parsing JSON test output:", parseError);
              }
            } catch (error) {
              console.log("Error reading test JSON logs:", error);
              testOutput = "Failed to read test output: " + error.message;
            }
            
            // Determine overall status
            const compileSuccess = ${{ steps.compile.outputs.exit_code == '0' }};
            const testSuccess = ${{ steps.run_tests.outputs.exit_code == '0' }};
            const overallStatus = compileSuccess && testSuccess ? 'success' : 'failure';
            const failureReason = !compileSuccess ? 'compilation_failure' : 
                                 !testSuccess ? 'test_failure' : null;
            
            // Create log document
            const logDocument = {
              repository: context.repo.repo,
              owner: context.repo.owner,
              workflow_name: context.workflow,
              job_name: context.job,
              run_id: context.runId,
              run_number: context.runNumber,
              sha: context.sha,
              ref: context.ref,
              event_name: context.eventName,
              actor: context.actor,
              timestamp: new Date().toISOString(),
              status: overallStatus,
              failure_reason: failureReason,
              compile_success: compileSuccess,
              test_success: testSuccess,
              compile_output: compileOutput,
              test_output_raw: testOutput,
              test_output_json: testJsonOutput.length > 0 ? testJsonOutput : null,
              commit_message: context.payload.head_commit ? context.payload.head_commit.message : 'No commit message available',
              branch: context.ref.replace('refs/heads/', '')
            };
            
            // Send to Elasticsearch
            try {
              console.log("Sending logs to Elasticsearch...");
              const response = await fetch(`${process.env.ELASTICSEARCH_URL}/${process.env.ELASTICSEARCH_INDEX}/_doc`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `ApiKey ${process.env.ELASTICSEARCH_API_KEY}`
                },
                body: JSON.stringify(logDocument)
              });
            
              if (!response.ok) {
                const errorText = await response.text();
                core.setFailed(`Failed to send logs to Elasticsearch: ${response.status} ${errorText}`);
              } else {
                console.log('Successfully sent logs to Elasticsearch');
              }
            } catch (error) {
              core.setFailed(`Error sending logs to Elasticsearch: ${error.message}`);
            }
        env:
          ELASTICSEARCH_API_KEY: ${{ secrets.ELASTICSEARCH_API_KEY }}

      # This ensures the workflow fails if either compilation or tests failed
      - name: Check results
        if: steps.compile.outputs.exit_code != '0' || steps.run_tests.outputs.exit_code != '0'
        run: |
          if [ "${{ steps.compile.outputs.exit_code }}" != "0" ]; then
            echo "Compilation failed"
            exit 1
          else
            echo "Tests failed"
            exit 1
          fi