name: Tests

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

env:
  CARGO_TERM_COLOR: always
  ELASTICSEARCH_URL: ${{ secrets.ELASTICSEARCH_ENDPOINT }}
  ELASTICSEARCH_INDEX: "flint-workflow-logs"

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/cache@v4
        with:
          path: |
            ~/.cargo/bin/
            ~/.cargo/registry/index/
            ~/.cargo/registry/cache/
            ~/.cargo/git/db/
            target/
          key: ${{ runner.os }}-cargo-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-

      - name: Run tests
        id: run_tests
        run: |
          # Run tests with headless output and capture to a file
          mkdir -p test_logs
          
          # Use --no-capture to get all output, --color never to disable colors
          # and --format=plain for plain text output without terminal formatting
          CARGO_TERM_COLOR=never cargo test -- --no-capture --color never --format=plain > test_logs/test_output.log 2>&1 || echo "Tests failed but continuing to capture logs"
          
          # Save the exit code
          echo "exit_code=$?" >> $GITHUB_OUTPUT
        continue-on-error: true

      - name: Send logs to Elasticsearch
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            
            // Read the test output file
            let testOutput;
            try {
              testOutput = fs.readFileSync('test_logs/test_output.log', 'utf8');
              console.log("Successfully read test logs");
            } catch (error) {
              console.log("Error reading test logs:", error);
              testOutput = "Failed to read test output: " + error.message;
            }
            
            // Create log document
            const logDocument = {
              repository: context.repo.repo,
              owner: context.repo.owner,
              workflow_name: context.workflow,
              job_name: context.job,
              run_id: context.runId,
              run_number: context.runNumber,
              sha: context.sha,
              ref: context.ref,
              event_name: context.eventName,
              actor: context.actor,
              timestamp: new Date().toISOString(),
              status: ${{ steps.run_tests.outputs.exit_code == '0' }} ? 'success' : 'failure',
              test_output: testOutput,
              commit_message: context.payload.head_commit ? context.payload.head_commit.message : 'No commit message available',
              branch: context.ref.replace('refs/heads/', '')
            };
            
            // Send to Elasticsearch
            try {
              console.log("Sending logs to Elasticsearch...");
              const response = await fetch(`${process.env.ELASTICSEARCH_URL}/${process.env.ELASTICSEARCH_INDEX}/_doc`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'Authorization': `ApiKey ${process.env.ELASTICSEARCH_API_KEY}`
                },
                body: JSON.stringify(logDocument)
              });
            
              if (!response.ok) {
                const errorText = await response.text();
                core.setFailed(`Failed to send logs to Elasticsearch: ${response.status} ${errorText}`);
              } else {
                console.log('Successfully sent logs to Elasticsearch');
              }
            } catch (error) {
              core.setFailed(`Error sending logs to Elasticsearch: ${error.message}`);
            }
        env:
          ELASTICSEARCH_API_KEY: ${{ secrets.ELASTICSEARCH_API_KEY }}

      # This ensures the workflow fails if the tests failed
      - name: Check test results
        if: steps.run_tests.outputs.exit_code != '0'
        run: exit 1